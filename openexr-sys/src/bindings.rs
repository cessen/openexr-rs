/* automatically generated by rust-bindgen */

pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 24;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
/**
 * An 2d integer vector.
 *
 * Used in various parts of OpenEXR's APIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_V2i {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CEXR_V2i() {
    assert_eq!(::std::mem::size_of::<CEXR_V2i>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CEXR_V2i ) ));
    assert_eq! (::std::mem::align_of::<CEXR_V2i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_V2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2i ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2i ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2i ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2i ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for CEXR_V2i {
    fn clone(&self) -> Self { *self }
}
/**
 * An 2d floating point vector.
 *
 * Used in various parts of OpenEXR's APIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_V2f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_CEXR_V2f() {
    assert_eq!(::std::mem::size_of::<CEXR_V2f>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CEXR_V2f ) ));
    assert_eq! (::std::mem::align_of::<CEXR_V2f>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_V2f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2f ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2f ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2f ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2f ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for CEXR_V2f {
    fn clone(&self) -> Self { *self }
}
/**
 * An 2d integer bounding box.
 *
 * Used in various parts of OpenEXR's APIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_Box2i {
    pub min: CEXR_V2i,
    pub max: CEXR_V2i,
}
#[test]
fn bindgen_test_layout_CEXR_Box2i() {
    assert_eq!(::std::mem::size_of::<CEXR_Box2i>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CEXR_Box2i ) ));
    assert_eq! (::std::mem::align_of::<CEXR_Box2i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_Box2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Box2i ) ) . min as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Box2i ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Box2i ) ) . max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Box2i ) , "::" ,
                stringify ! ( max ) ));
}
impl Clone for CEXR_Box2i {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Describes the datatype of an image channel.
 *
 * * `UINT`: 32-bit unsigned integer.
 * * `HALF`: 16-bit floating point (conforming to IEEE 754).
 * * `FLOAT`: 32-bit floating point (conforming to IEEE 754)
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_PixelType { UINT = 0, HALF = 1, FLOAT = 2, }
#[repr(u32)]
/**
 * Defines the line order of a scanline image.
 *
 * For scanline images, only `INCREASING_Y` and `DECREASING_Y` are valid
 * values:
 *
 * * `INCREASING_Y`: scanline 0 is the first scanline in the file, and
 *   scanlines are written and read in that order.
 *
 * * `DECREASING_Y`: scanline 0 is the last scanline in the file, and
 *   scanlines are written and read in that order.
 *
 * In both cases, scanlines are written to and read from files in the order
 * they are stored on disk, and any `FrameBuffer` you pass is interpretted
 * that way as well.
 *
 * For tiled images, all values are valid, but they have different meanings:
 *
 * * `INCREASING_Y`: the tiles are stored in a particular order.  See
 *   OpenEXR's
 *   [ImfTiledOutputFile.h]
 *   (https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfTiledOutputFile.h)
 *   header for specifics.
 * 
 * * `DECREASING_Y`: the tiles are stored in a different particular order.
 *   See OpenEXR's
 *   [ImfTiledOutputFile.h]
 *   (https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfTiledOutputFile.h)
 *   header for specifics.
 * 
 * * `RANDOM_Y`: the tiles are stored in the order written.
 *
 * For tiled files, `RANDOM_Y` is probably a good choice, as it gives you
 * control over the tile layout and doesn't require the OpenEXR library to
 * do any buffering.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_LineOrder { INCREASING_Y = 0, DECREASING_Y = 1, RANDOM_Y = 2, }
#[repr(u32)]
/**
 * Compression mode of an OpenEXR file.
 *
 * These modes are lossless:
 * 
 * * `NO_COMPRESSION`
 * * `RLE_COMPRESSION`
 * * `ZIPS_COMPRESSION`
 * * `ZIP_COMPRESSION`
 * * `PIZ_COMPRESSION`
 *
 * These modes are lossy:
 *
 * * `PXR24_COMPRESSION`
 * * `B44_COMPRESSION`
 * * `B44A_COMPRESSION`
 * * `DWAA_COMPRESSION`
 * * `DWAB_COMPRESSION`
 *
 * And `PXR24_COMPRESSION` is only lossy for 32-bit floating point channels,
 * which it converts to 24-bit floating point.
 *
 * See OpenEXR's documentation and header files for more details on the
 * compression modes.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_Compression {
    NO_COMPRESSION = 0,
    RLE_COMPRESSION = 1,
    ZIPS_COMPRESSION = 2,
    ZIP_COMPRESSION = 3,
    PIZ_COMPRESSION = 4,
    PXR24_COMPRESSION = 5,
    B44_COMPRESSION = 6,
    B44A_COMPRESSION = 7,
    DWAA_COMPRESSION = 8,
    DWAB_COMPRESSION = 9,
}
/**
 * Describes an image channel.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_Channel {
    pub pixel_type: CEXR_PixelType,
    pub x_sampling: ::std::os::raw::c_int,
    pub y_sampling: ::std::os::raw::c_int,
    pub p_linear: bool,
}
#[test]
fn bindgen_test_layout_CEXR_Channel() {
    assert_eq!(::std::mem::size_of::<CEXR_Channel>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CEXR_Channel ) ));
    assert_eq! (::std::mem::align_of::<CEXR_Channel>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_Channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . pixel_type as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( pixel_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . x_sampling as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( x_sampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . y_sampling as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( y_sampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . p_linear as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( p_linear ) ));
}
impl Clone for CEXR_Channel {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_InputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_OutputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Header {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_FrameBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_IStream {
    _unused: [u8; 0],
}
pub type CEXR_OStream = CEXR_IStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_ChannelListIter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn CEXR_IStream_from_memory(filename: *const ::std::os::raw::c_char,
                                    data: *mut ::std::os::raw::c_char,
                                    size: usize) -> *mut CEXR_IStream;
}
extern "C" {
    pub fn CEXR_IStream_delete(stream: *mut CEXR_IStream);
}
extern "C" {
    pub fn CEXR_OStream_from_stream_writer(writer:
                                               *mut ::std::os::raw::c_void,
                                           write_ptr:
                                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                              *mut ::std::os::raw::c_void,
                                                                                          arg2:
                                                                                              *const ::std::os::raw::c_char,
                                                                                          arg3:
                                                                                              ::std::os::raw::c_int)
                                                                         ->
                                                                             ::std::os::raw::c_int>,
                                           seekp_ptr:
                                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                              *mut ::std::os::raw::c_void,
                                                                                          arg2:
                                                                                              u64)
                                                                         ->
                                                                             ::std::os::raw::c_int>)
     -> *mut CEXR_OStream;
}
extern "C" {
    pub fn CEXR_OStream_delete(stream: *mut CEXR_OStream);
}
extern "C" {
    pub fn CEXR_ChannelListIter_next(iter: *mut CEXR_ChannelListIter,
                                     name: *mut *const ::std::os::raw::c_char,
                                     channel: *mut CEXR_Channel) -> bool;
}
extern "C" {
    pub fn CEXR_ChannelListIter_delete(iter: *mut CEXR_ChannelListIter);
}
extern "C" {
    pub fn CEXR_Header_new(displayWindow: *const CEXR_Box2i,
                           dataWindow: *const CEXR_Box2i,
                           pixelAspectRatio: f32,
                           screenWindowCenter: *const CEXR_V2f,
                           screenWindowWidth: f32, lineOrder: CEXR_LineOrder,
                           compression: CEXR_Compression) -> *mut CEXR_Header;
}
extern "C" {
    pub fn CEXR_Header_delete(header: *mut CEXR_Header);
}
extern "C" {
    pub fn CEXR_Header_insert_channel(header: *mut CEXR_Header,
                                      name: *const ::std::os::raw::c_char,
                                      channel: CEXR_Channel);
}
extern "C" {
    pub fn CEXR_Header_get_channel(header: *const CEXR_Header,
                                   name: *const ::std::os::raw::c_char,
                                   out: *mut *const CEXR_Channel,
                                   err_out:
                                       *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_Header_channel_list_iter(header: *const CEXR_Header)
     -> *mut CEXR_ChannelListIter;
}
extern "C" {
    pub fn CEXR_Header_display_window(header: *const CEXR_Header)
     -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_data_window(header: *const CEXR_Header)
     -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_set_display_window(header: *mut CEXR_Header,
                                          window: CEXR_Box2i);
}
extern "C" {
    pub fn CEXR_Header_set_data_window(header: *mut CEXR_Header,
                                       window: CEXR_Box2i);
}
extern "C" {
    pub fn CEXR_Header_set_pixel_aspect_ratio(header: *mut CEXR_Header,
                                              aspect_ratio: f32);
}
extern "C" {
    pub fn CEXR_Header_set_screen_window_center(header: *mut CEXR_Header,
                                                center: CEXR_V2f);
}
extern "C" {
    pub fn CEXR_Header_set_screen_window_width(header: *mut CEXR_Header,
                                               width: f32);
}
extern "C" {
    pub fn CEXR_Header_set_line_order(header: *mut CEXR_Header,
                                      line_order: CEXR_LineOrder);
}
extern "C" {
    pub fn CEXR_Header_set_compression(header: *mut CEXR_Header,
                                       compression: CEXR_Compression);
}
extern "C" {
    pub fn CEXR_FrameBuffer_new() -> *mut CEXR_FrameBuffer;
}
extern "C" {
    pub fn CEXR_FrameBuffer_delete(framebuffer: *mut CEXR_FrameBuffer);
}
extern "C" {
    pub fn CEXR_FrameBuffer_insert(framebuffer: *mut CEXR_FrameBuffer,
                                   name: *const ::std::os::raw::c_char,
                                   type_: CEXR_PixelType,
                                   base: *mut ::std::os::raw::c_char,
                                   xStride: usize, yStride: usize,
                                   xSampling: ::std::os::raw::c_int,
                                   ySampling: ::std::os::raw::c_int,
                                   fillValue: f64,
                                   xTileCoords: ::std::os::raw::c_int,
                                   yTileCoords: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CEXR_InputFile_from_file(path: *const ::std::os::raw::c_char,
                                    threads: ::std::os::raw::c_int,
                                    out: *mut *mut CEXR_InputFile,
                                    err_out:
                                        *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_from_stream(stream: *mut CEXR_IStream,
                                      threads: ::std::os::raw::c_int,
                                      out: *mut *mut CEXR_InputFile,
                                      err_out:
                                          *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_delete(file: *mut CEXR_InputFile);
}
extern "C" {
    pub fn CEXR_InputFile_header(file: *mut CEXR_InputFile)
     -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_InputFile_set_framebuffer(file: *mut CEXR_InputFile,
                                          framebuffer: *mut CEXR_FrameBuffer,
                                          err_out:
                                              *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_read_pixels(file: *mut CEXR_InputFile,
                                      scanline_1: ::std::os::raw::c_int,
                                      scanline_2: ::std::os::raw::c_int,
                                      err_out:
                                          *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_from_file(path: *const ::std::os::raw::c_char,
                                     header: *const CEXR_Header,
                                     threads: ::std::os::raw::c_int,
                                     out: *mut *mut CEXR_OutputFile,
                                     err_out:
                                         *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_from_stream(stream: *mut CEXR_OStream,
                                       header: *const CEXR_Header,
                                       threads: ::std::os::raw::c_int,
                                       out: *mut *mut CEXR_OutputFile,
                                       err_out:
                                           *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_delete(file: *mut CEXR_OutputFile);
}
extern "C" {
    pub fn CEXR_OutputFile_header(file: *mut CEXR_OutputFile)
     -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_OutputFile_set_framebuffer(file: *mut CEXR_OutputFile,
                                           framebuffer:
                                               *const CEXR_FrameBuffer,
                                           err_out:
                                               *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_write_pixels(file: *mut CEXR_OutputFile,
                                        num_scanlines: ::std::os::raw::c_int,
                                        err_out:
                                            *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
