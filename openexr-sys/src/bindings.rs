/* automatically generated by rust-bindgen */

pub type __uint64_t = ::std::os::raw::c_ulong;
/// A 2d integer vector.
///
/// Used in various parts of OpenEXR's APIs.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_V2i {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CEXR_V2i() {
    assert_eq!(
        ::std::mem::size_of::<CEXR_V2i>(),
        8usize,
        concat!("Size of: ", stringify!(CEXR_V2i))
    );
    assert_eq!(
        ::std::mem::align_of::<CEXR_V2i>(),
        4usize,
        concat!("Alignment of ", stringify!(CEXR_V2i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_V2i>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_V2i),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_V2i>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_V2i),
            "::",
            stringify!(y)
        )
    );
}
/// A 2d floating point vector.
///
/// Used in various parts of OpenEXR's APIs.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_V2f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_CEXR_V2f() {
    assert_eq!(
        ::std::mem::size_of::<CEXR_V2f>(),
        8usize,
        concat!("Size of: ", stringify!(CEXR_V2f))
    );
    assert_eq!(
        ::std::mem::align_of::<CEXR_V2f>(),
        4usize,
        concat!("Alignment of ", stringify!(CEXR_V2f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_V2f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_V2f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_V2f>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_V2f),
            "::",
            stringify!(y)
        )
    );
}
/// A 2d integer bounding box.
///
/// Used in various parts of OpenEXR's APIs.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Box2i {
    pub min: CEXR_V2i,
    pub max: CEXR_V2i,
}
#[test]
fn bindgen_test_layout_CEXR_Box2i() {
    assert_eq!(
        ::std::mem::size_of::<CEXR_Box2i>(),
        16usize,
        concat!("Size of: ", stringify!(CEXR_Box2i))
    );
    assert_eq!(
        ::std::mem::align_of::<CEXR_Box2i>(),
        4usize,
        concat!("Alignment of ", stringify!(CEXR_Box2i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Box2i>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Box2i),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Box2i>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Box2i),
            "::",
            stringify!(max)
        )
    );
}
#[repr(u32)]
/// Describes the datatype of an image channel.
///
/// * `UINT`: 32-bit unsigned integer.
/// * `HALF`: 16-bit floating point (conforming to IEEE 754).
/// * `FLOAT`: 32-bit floating point (conforming to IEEE 754)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_PixelType {
    UINT = 0,
    HALF = 1,
    FLOAT = 2,
}
#[repr(u32)]
/// Defines the line order of a scanline image.
///
/// For scanline images, only `INCREASING_Y` and `DECREASING_Y` are valid
/// values:
///
/// * `INCREASING_Y`: scanline 0 is the first scanline in the file, and
///   scanlines are written and read in that order.
///
/// * `DECREASING_Y`: scanline 0 is the last scanline in the file, and
///   scanlines are written and read in that order.
///
/// In both cases, scanlines are written to and read from files in the order
/// they are stored on disk, and any `FrameBuffer` you pass is interpretted
/// that way as well.
///
/// For tiled images, all values are valid, but they have different meanings:
///
/// * `INCREASING_Y`: the tiles are stored in a particular order.  See
///   OpenEXR's
///   [ImfTiledOutputFile.h]
///   (https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfTiledOutputFile.h)
///   header for specifics.
///
/// * `DECREASING_Y`: the tiles are stored in a different particular order.
///   See OpenEXR's
///   [ImfTiledOutputFile.h]
///   (https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfTiledOutputFile.h)
///   header for specifics.
///
/// * `RANDOM_Y`: the tiles are stored in the order written.
///
/// For tiled files, `RANDOM_Y` is probably a good choice, as it gives you
/// control over the tile layout and doesn't require the OpenEXR library to
/// do any buffering.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_LineOrder {
    INCREASING_Y = 0,
    DECREASING_Y = 1,
    RANDOM_Y = 2,
}
#[repr(u32)]
/// Compression mode of an OpenEXR file.
///
/// These modes are lossless:
///
/// * `NO_COMPRESSION`
/// * `RLE_COMPRESSION`
/// * `ZIPS_COMPRESSION`
/// * `ZIP_COMPRESSION`
/// * `PIZ_COMPRESSION`
///
/// These modes are lossy:
///
/// * `PXR24_COMPRESSION`
/// * `B44_COMPRESSION`
/// * `B44A_COMPRESSION`
/// * `DWAA_COMPRESSION`
/// * `DWAB_COMPRESSION`
///
/// And `PXR24_COMPRESSION` is only lossy for 32-bit floating point channels,
/// which it converts to 24-bit floating point.
///
/// See OpenEXR's documentation and header files for more details on the
/// compression modes.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_Compression {
    NO_COMPRESSION = 0,
    RLE_COMPRESSION = 1,
    ZIPS_COMPRESSION = 2,
    ZIP_COMPRESSION = 3,
    PIZ_COMPRESSION = 4,
    PXR24_COMPRESSION = 5,
    B44_COMPRESSION = 6,
    B44A_COMPRESSION = 7,
    DWAA_COMPRESSION = 8,
    DWAB_COMPRESSION = 9,
}
/// Describes an image channel.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Channel {
    pub pixel_type: CEXR_PixelType,
    pub x_sampling: ::std::os::raw::c_int,
    pub y_sampling: ::std::os::raw::c_int,
    pub p_linear: bool,
}
#[test]
fn bindgen_test_layout_CEXR_Channel() {
    assert_eq!(
        ::std::mem::size_of::<CEXR_Channel>(),
        16usize,
        concat!("Size of: ", stringify!(CEXR_Channel))
    );
    assert_eq!(
        ::std::mem::align_of::<CEXR_Channel>(),
        4usize,
        concat!("Alignment of ", stringify!(CEXR_Channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Channel>())).pixel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Channel),
            "::",
            stringify!(pixel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Channel>())).x_sampling as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Channel),
            "::",
            stringify!(x_sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Channel>())).y_sampling as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Channel),
            "::",
            stringify!(y_sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Channel>())).p_linear as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Channel),
            "::",
            stringify!(p_linear)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_InputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_OutputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Header {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_FrameBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_IStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_OStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_ChannelListIter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Slice {
    pub ptr: *mut ::std::os::raw::c_void,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_CEXR_Slice() {
    assert_eq!(
        ::std::mem::size_of::<CEXR_Slice>(),
        16usize,
        concat!("Size of: ", stringify!(CEXR_Slice))
    );
    assert_eq!(
        ::std::mem::align_of::<CEXR_Slice>(),
        8usize,
        concat!("Alignment of ", stringify!(CEXR_Slice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Slice>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Slice),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CEXR_Slice>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CEXR_Slice),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn CEXR_IStream_from_reader(
        reader: *mut ::std::os::raw::c_void,
        read_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
                err_out: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        seekp_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: u64,
                err_out: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        out: *mut *mut CEXR_IStream,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_IStream_from_memory(
        filename: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *mut CEXR_IStream;
}
extern "C" {
    pub fn CEXR_IStream_delete(stream: *mut CEXR_IStream);
}
extern "C" {
    pub fn CEXR_OStream_from_writer(
        writer: *mut ::std::os::raw::c_void,
        write_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
                err_out: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        seekp_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: u64,
                err_out: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        out: *mut *mut CEXR_OStream,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OStream_delete(stream: *mut CEXR_OStream);
}
extern "C" {
    pub fn CEXR_ChannelListIter_next(
        iter: *mut CEXR_ChannelListIter,
        name: *mut *const ::std::os::raw::c_char,
        channel: *mut CEXR_Channel,
    ) -> bool;
}
extern "C" {
    pub fn CEXR_ChannelListIter_delete(iter: *mut CEXR_ChannelListIter);
}
extern "C" {
    pub fn CEXR_Header_new(
        displayWindow: *const CEXR_Box2i,
        dataWindow: *const CEXR_Box2i,
        pixelAspectRatio: f32,
        screenWindowCenter: *const CEXR_V2f,
        screenWindowWidth: f32,
        lineOrder: CEXR_LineOrder,
        compression: CEXR_Compression,
    ) -> *mut CEXR_Header;
}
extern "C" {
    pub fn CEXR_Header_delete(header: *mut CEXR_Header);
}
extern "C" {
    pub fn CEXR_Header_insert_channel(
        header: *mut CEXR_Header,
        name: *const ::std::os::raw::c_char,
        channel: CEXR_Channel,
    );
}
extern "C" {
    pub fn CEXR_Header_get_channel(
        header: *const CEXR_Header,
        name: *const ::std::os::raw::c_char,
    ) -> *const CEXR_Channel;
}
extern "C" {
    pub fn CEXR_Header_channel_list_iter(header: *const CEXR_Header) -> *mut CEXR_ChannelListIter;
}
extern "C" {
    pub fn CEXR_Header_display_window(header: *const CEXR_Header) -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_data_window(header: *const CEXR_Header) -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_set_display_window(header: *mut CEXR_Header, window: CEXR_Box2i);
}
extern "C" {
    pub fn CEXR_Header_set_data_window(header: *mut CEXR_Header, window: CEXR_Box2i);
}
extern "C" {
    pub fn CEXR_Header_set_pixel_aspect_ratio(header: *mut CEXR_Header, aspect_ratio: f32);
}
extern "C" {
    pub fn CEXR_Header_set_screen_window_center(header: *mut CEXR_Header, center: CEXR_V2f);
}
extern "C" {
    pub fn CEXR_Header_set_screen_window_width(header: *mut CEXR_Header, width: f32);
}
extern "C" {
    pub fn CEXR_Header_set_line_order(header: *mut CEXR_Header, line_order: CEXR_LineOrder);
}
extern "C" {
    pub fn CEXR_Header_set_compression(header: *mut CEXR_Header, compression: CEXR_Compression);
}
extern "C" {
    pub fn CEXR_Header_has_envmap(header: *const CEXR_Header) -> bool;
}
extern "C" {
    pub fn CEXR_Header_envmap(header: *const CEXR_Header) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_Header_set_envmap(header: *mut CEXR_Header, envmap: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CEXR_Header_has_multiview(header: *const CEXR_Header) -> bool;
}
extern "C" {
    pub fn CEXR_Header_multiview(header: *const CEXR_Header, out: *mut CEXR_Slice) -> usize;
}
extern "C" {
    pub fn CEXR_Header_set_multiview(
        header: *mut CEXR_Header,
        views: *const CEXR_Slice,
        view_count: usize,
    );
}
extern "C" {
    pub fn CEXR_Header_erase_attribute(
        header: *mut CEXR_Header,
        attribute: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn CEXR_FrameBuffer_new() -> *mut CEXR_FrameBuffer;
}
extern "C" {
    pub fn CEXR_FrameBuffer_delete(framebuffer: *mut CEXR_FrameBuffer);
}
extern "C" {
    pub fn CEXR_FrameBuffer_insert(
        framebuffer: *mut CEXR_FrameBuffer,
        name: *const ::std::os::raw::c_char,
        type_: CEXR_PixelType,
        base: *mut ::std::os::raw::c_char,
        xStride: usize,
        yStride: usize,
        xSampling: ::std::os::raw::c_int,
        ySampling: ::std::os::raw::c_int,
        fillValue: f64,
        xTileCoords: ::std::os::raw::c_int,
        yTileCoords: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CEXR_FrameBuffer_get_channel(
        frame_buffer: *const CEXR_FrameBuffer,
        name: *const ::std::os::raw::c_char,
        out: *mut CEXR_Channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_FrameBuffer_copy_and_offset_scanlines(
        frame_buffer: *const CEXR_FrameBuffer,
        offset: ::std::os::raw::c_uint,
    ) -> *mut CEXR_FrameBuffer;
}
extern "C" {
    pub fn CEXR_InputFile_from_file_path(
        path: *const ::std::os::raw::c_char,
        threads: ::std::os::raw::c_int,
        out: *mut *mut CEXR_InputFile,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_from_stream(
        stream: *mut CEXR_IStream,
        threads: ::std::os::raw::c_int,
        out: *mut *mut CEXR_InputFile,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_delete(file: *mut CEXR_InputFile);
}
extern "C" {
    pub fn CEXR_InputFile_header(file: *mut CEXR_InputFile) -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_InputFile_set_framebuffer(
        file: *mut CEXR_InputFile,
        framebuffer: *mut CEXR_FrameBuffer,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_read_pixels(
        file: *mut CEXR_InputFile,
        scanline_1: ::std::os::raw::c_int,
        scanline_2: ::std::os::raw::c_int,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_from_stream(
        stream: *mut CEXR_OStream,
        header: *const CEXR_Header,
        threads: ::std::os::raw::c_int,
        out: *mut *mut CEXR_OutputFile,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_delete(file: *mut CEXR_OutputFile);
}
extern "C" {
    pub fn CEXR_OutputFile_header(file: *mut CEXR_OutputFile) -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_OutputFile_set_framebuffer(
        file: *mut CEXR_OutputFile,
        framebuffer: *const CEXR_FrameBuffer,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_write_pixels(
        file: *mut CEXR_OutputFile,
        num_scanlines: ::std::os::raw::c_int,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_set_global_thread_count(
        thread_count: ::std::os::raw::c_int,
        err_out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
