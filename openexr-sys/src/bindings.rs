/* automatically generated by rust-bindgen */

pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_V2i {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CEXR_V2i() {
    assert_eq!(::std::mem::size_of::<CEXR_V2i>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CEXR_V2i ) ));
    assert_eq! (::std::mem::align_of::<CEXR_V2i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_V2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2i ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2i ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2i ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2i ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for CEXR_V2i {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_V2f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_CEXR_V2f() {
    assert_eq!(::std::mem::size_of::<CEXR_V2f>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CEXR_V2f ) ));
    assert_eq! (::std::mem::align_of::<CEXR_V2f>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_V2f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2f ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2f ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2f ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2f ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for CEXR_V2f {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_Box2i {
    pub min: CEXR_V2i,
    pub max: CEXR_V2i,
}
#[test]
fn bindgen_test_layout_CEXR_Box2i() {
    assert_eq!(::std::mem::size_of::<CEXR_Box2i>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CEXR_Box2i ) ));
    assert_eq! (::std::mem::align_of::<CEXR_Box2i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_Box2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Box2i ) ) . min as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Box2i ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Box2i ) ) . max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Box2i ) , "::" ,
                stringify ! ( max ) ));
}
impl Clone for CEXR_Box2i {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_PixelType { UINT = 0, HALF = 1, FLOAT = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_LineOrder { INCREASING_Y = 0, DECREASING_Y = 1, RANDOM_Y = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_Compression {
    NO_COMPRESSION = 0,
    RLE_COMPRESSION = 1,
    ZIPS_COMPRESSION = 2,
    ZIP_COMPRESSION = 3,
    PIZ_COMPRESSION = 4,
    PXR24_COMPRESSION = 5,
    B44_COMPRESSION = 6,
    B44A_COMPRESSION = 7,
    DWAA_COMPRESSION = 8,
    DWAB_COMPRESSION = 9,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_Channel {
    pub pixel_type: CEXR_PixelType,
    pub x_sampling: ::std::os::raw::c_int,
    pub y_sampling: ::std::os::raw::c_int,
    pub p_linear: bool,
}
#[test]
fn bindgen_test_layout_CEXR_Channel() {
    assert_eq!(::std::mem::size_of::<CEXR_Channel>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CEXR_Channel ) ));
    assert_eq! (::std::mem::align_of::<CEXR_Channel>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_Channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . pixel_type as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( pixel_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . x_sampling as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( x_sampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . y_sampling as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( y_sampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . p_linear as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( p_linear ) ));
}
impl Clone for CEXR_Channel {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_InputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_OutputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Header {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_FrameBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_IStream {
    _unused: [u8; 0],
}
extern "C" {
    pub fn CEXR_IStream_from_memory(filename: *const ::std::os::raw::c_char,
                                    data: *mut ::std::os::raw::c_char,
                                    size: usize) -> *mut CEXR_IStream;
}
extern "C" {
    pub fn CEXR_IStream_delete(stream: *mut CEXR_IStream);
}
extern "C" {
    pub fn CEXR_Header_new(displayWindow: *const CEXR_Box2i,
                           dataWindow: *const CEXR_Box2i,
                           pixelAspectRatio: f32,
                           screenWindowCenter: *const CEXR_V2f,
                           screenWindowWidth: f32, lineOrder: CEXR_LineOrder,
                           compression: CEXR_Compression) -> *mut CEXR_Header;
}
extern "C" {
    pub fn CEXR_Header_delete(header: *mut CEXR_Header);
}
extern "C" {
    pub fn CEXR_Header_insert_channel(header: *mut CEXR_Header,
                                      name: *const ::std::os::raw::c_char,
                                      channel: CEXR_Channel);
}
extern "C" {
    pub fn CEXR_Header_display_window(header: *const CEXR_Header)
     -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_data_window(header: *const CEXR_Header)
     -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_FrameBuffer_new() -> *mut CEXR_FrameBuffer;
}
extern "C" {
    pub fn CEXR_FrameBuffer_delete(framebuffer: *mut CEXR_FrameBuffer);
}
extern "C" {
    pub fn CEXR_FrameBuffer_insert(framebuffer: *mut CEXR_FrameBuffer,
                                   name: *const ::std::os::raw::c_char,
                                   type_: CEXR_PixelType,
                                   base: *mut ::std::os::raw::c_char,
                                   xStride: usize, yStride: usize,
                                   xSampling: ::std::os::raw::c_int,
                                   ySampling: ::std::os::raw::c_int,
                                   fillValue: f64,
                                   xTileCoords: ::std::os::raw::c_int,
                                   yTileCoords: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CEXR_InputFile_from_file(path: *const ::std::os::raw::c_char,
                                    threads: ::std::os::raw::c_int,
                                    out: *mut *mut CEXR_InputFile,
                                    err_out:
                                        *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_from_stream(stream: *mut CEXR_IStream,
                                      threads: ::std::os::raw::c_int,
                                      out: *mut *mut CEXR_InputFile,
                                      err_out:
                                          *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_delete(file: *mut CEXR_InputFile);
}
extern "C" {
    pub fn CEXR_InputFile_header(file: *mut CEXR_InputFile)
     -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_InputFile_set_framebuffer(file: *mut CEXR_InputFile,
                                          framebuffer: *mut CEXR_FrameBuffer);
}
extern "C" {
    pub fn CEXR_InputFile_read_pixels(file: *mut CEXR_InputFile,
                                      scanline_1: ::std::os::raw::c_int,
                                      scanline_2: ::std::os::raw::c_int,
                                      err_out:
                                          *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_from_file(path: *const ::std::os::raw::c_char,
                                     header: *const CEXR_Header,
                                     threads: ::std::os::raw::c_int,
                                     out: *mut *mut CEXR_OutputFile,
                                     err_out:
                                         *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_delete(file: *mut CEXR_OutputFile);
}
extern "C" {
    pub fn CEXR_OutputFile_header(file: *mut CEXR_OutputFile)
     -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_OutputFile_set_framebuffer(file: *mut CEXR_OutputFile,
                                           framebuffer:
                                               *mut CEXR_FrameBuffer);
}
extern "C" {
    pub fn CEXR_OutputFile_write_pixels(file: *mut CEXR_OutputFile,
                                        num_scanlines: ::std::os::raw::c_int,
                                        err_out:
                                            *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
