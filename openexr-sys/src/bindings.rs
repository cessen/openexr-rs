/* automatically generated by rust-bindgen */

/**
 * A 2d integer vector.
 *
 * Used in various parts of OpenEXR's APIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_V2i {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CEXR_V2i() {
    assert_eq!(::std::mem::size_of::<CEXR_V2i>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CEXR_V2i ) ));
    assert_eq! (::std::mem::align_of::<CEXR_V2i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_V2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2i ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2i ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2i ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2i ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for CEXR_V2i {
    fn clone(&self) -> Self { *self }
}
/**
 * A 2d floating point vector.
 *
 * Used in various parts of OpenEXR's APIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_V2f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_CEXR_V2f() {
    assert_eq!(::std::mem::size_of::<CEXR_V2f>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CEXR_V2f ) ));
    assert_eq! (::std::mem::align_of::<CEXR_V2f>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_V2f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2f ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2f ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_V2f ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_V2f ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for CEXR_V2f {
    fn clone(&self) -> Self { *self }
}
/**
 * A 2d integer bounding box.
 *
 * Used in various parts of OpenEXR's APIs.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_Box2i {
    pub min: CEXR_V2i,
    pub max: CEXR_V2i,
}
#[test]
fn bindgen_test_layout_CEXR_Box2i() {
    assert_eq!(::std::mem::size_of::<CEXR_Box2i>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CEXR_Box2i ) ));
    assert_eq! (::std::mem::align_of::<CEXR_Box2i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_Box2i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Box2i ) ) . min as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Box2i ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Box2i ) ) . max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Box2i ) , "::" ,
                stringify ! ( max ) ));
}
impl Clone for CEXR_Box2i {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Describes the datatype of an image channel.
 *
 * * `UINT`: 32-bit unsigned integer.
 * * `HALF`: 16-bit floating point (conforming to IEEE 754).
 * * `FLOAT`: 32-bit floating point (conforming to IEEE 754)
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_PixelType { UINT = 0, HALF = 1, FLOAT = 2, }
#[repr(u32)]
/**
 * Defines the line order of a scanline image.
 *
 * For scanline images, only `INCREASING_Y` and `DECREASING_Y` are valid
 * values:
 *
 * * `INCREASING_Y`: scanline 0 is the first scanline in the file, and
 *   scanlines are written and read in that order.
 *
 * * `DECREASING_Y`: scanline 0 is the last scanline in the file, and
 *   scanlines are written and read in that order.
 *
 * In both cases, scanlines are written to and read from files in the order
 * they are stored on disk, and any `FrameBuffer` you pass is interpretted
 * that way as well.
 *
 * For tiled images, all values are valid, but they have different meanings:
 *
 * * `INCREASING_Y`: the tiles are stored in a particular order.  See
 *   OpenEXR's
 *   [ImfTiledOutputFile.h]
 *   (https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfTiledOutputFile.h)
 *   header for specifics.
 * 
 * * `DECREASING_Y`: the tiles are stored in a different particular order.
 *   See OpenEXR's
 *   [ImfTiledOutputFile.h]
 *   (https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfTiledOutputFile.h)
 *   header for specifics.
 * 
 * * `RANDOM_Y`: the tiles are stored in the order written.
 *
 * For tiled files, `RANDOM_Y` is probably a good choice, as it gives you
 * control over the tile layout and doesn't require the OpenEXR library to
 * do any buffering.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_LineOrder { INCREASING_Y = 0, DECREASING_Y = 1, RANDOM_Y = 2, }
#[repr(u32)]
/**
 * Compression mode of an OpenEXR file.
 *
 * These modes are lossless:
 * 
 * * `NO_COMPRESSION`
 * * `RLE_COMPRESSION`
 * * `ZIPS_COMPRESSION`
 * * `ZIP_COMPRESSION`
 * * `PIZ_COMPRESSION`
 *
 * These modes are lossy:
 *
 * * `PXR24_COMPRESSION`
 * * `B44_COMPRESSION`
 * * `B44A_COMPRESSION`
 * * `DWAA_COMPRESSION`
 * * `DWAB_COMPRESSION`
 *
 * And `PXR24_COMPRESSION` is only lossy for 32-bit floating point channels,
 * which it converts to 24-bit floating point.
 *
 * See OpenEXR's documentation and header files for more details on the
 * compression modes.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CEXR_Compression {
    NO_COMPRESSION = 0,
    RLE_COMPRESSION = 1,
    ZIPS_COMPRESSION = 2,
    ZIP_COMPRESSION = 3,
    PIZ_COMPRESSION = 4,
    PXR24_COMPRESSION = 5,
    B44_COMPRESSION = 6,
    B44A_COMPRESSION = 7,
    DWAA_COMPRESSION = 8,
    DWAB_COMPRESSION = 9,
}
/**
 * Describes an image channel.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CEXR_Channel {
    pub pixel_type: CEXR_PixelType,
    pub x_sampling: ::std::os::raw::c_int,
    pub y_sampling: ::std::os::raw::c_int,
    pub p_linear: bool,
}
#[test]
fn bindgen_test_layout_CEXR_Channel() {
    assert_eq!(::std::mem::size_of::<CEXR_Channel>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CEXR_Channel ) ));
    assert_eq! (::std::mem::align_of::<CEXR_Channel>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CEXR_Channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . pixel_type as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( pixel_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . x_sampling as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( x_sampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . y_sampling as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( y_sampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CEXR_Channel ) ) . p_linear as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CEXR_Channel ) , "::" ,
                stringify ! ( p_linear ) ));
}
impl Clone for CEXR_Channel {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_InputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_OutputFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_Header {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_FrameBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_IStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_OStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CEXR_ChannelListIter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn CEXR_IStream_from_reader(reader: *mut ::std::os::raw::c_void,
                                    read_ptr:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void,
                                                                                   arg2:
                                                                                       *mut ::std::os::raw::c_char,
                                                                                   arg3:
                                                                                       ::std::os::raw::c_int,
                                                                                   err_out:
                                                                                       *mut ::std::os::raw::c_int)
                                                                  ->
                                                                      ::std::os::raw::c_int>,
                                    seekp_ptr:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void,
                                                                                   arg2:
                                                                                       u64,
                                                                                   err_out:
                                                                                       *mut ::std::os::raw::c_int)
                                                                  ->
                                                                      ::std::os::raw::c_int>,
                                    out: *mut *mut CEXR_IStream,
                                    err_out:
                                        *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_IStream_from_memory(filename: *const ::std::os::raw::c_char,
                                    data: *mut ::std::os::raw::c_char,
                                    size: usize) -> *mut CEXR_IStream;
}
extern "C" {
    pub fn CEXR_IStream_delete(stream: *mut CEXR_IStream);
}
extern "C" {
    pub fn CEXR_OStream_from_writer(writer: *mut ::std::os::raw::c_void,
                                    write_ptr:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void,
                                                                                   arg2:
                                                                                       *const ::std::os::raw::c_char,
                                                                                   arg3:
                                                                                       ::std::os::raw::c_int,
                                                                                   err_out:
                                                                                       *mut ::std::os::raw::c_int)
                                                                  ->
                                                                      ::std::os::raw::c_int>,
                                    seekp_ptr:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void,
                                                                                   arg2:
                                                                                       u64,
                                                                                   err_out:
                                                                                       *mut ::std::os::raw::c_int)
                                                                  ->
                                                                      ::std::os::raw::c_int>,
                                    out: *mut *mut CEXR_OStream,
                                    err_out:
                                        *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OStream_delete(stream: *mut CEXR_OStream);
}
extern "C" {
    pub fn CEXR_ChannelListIter_next(iter: *mut CEXR_ChannelListIter,
                                     name: *mut *const ::std::os::raw::c_char,
                                     channel: *mut CEXR_Channel) -> bool;
}
extern "C" {
    pub fn CEXR_ChannelListIter_delete(iter: *mut CEXR_ChannelListIter);
}
extern "C" {
    pub fn CEXR_Header_new(displayWindow: *const CEXR_Box2i,
                           dataWindow: *const CEXR_Box2i,
                           pixelAspectRatio: f32,
                           screenWindowCenter: *const CEXR_V2f,
                           screenWindowWidth: f32, lineOrder: CEXR_LineOrder,
                           compression: CEXR_Compression) -> *mut CEXR_Header;
}
extern "C" {
    pub fn CEXR_Header_delete(header: *mut CEXR_Header);
}
extern "C" {
    pub fn CEXR_Header_insert_channel(header: *mut CEXR_Header,
                                      name: *const ::std::os::raw::c_char,
                                      channel: CEXR_Channel);
}
extern "C" {
    pub fn CEXR_Header_get_channel(header: *const CEXR_Header,
                                   name: *const ::std::os::raw::c_char)
     -> *const CEXR_Channel;
}
extern "C" {
    pub fn CEXR_Header_channel_list_iter(header: *const CEXR_Header)
     -> *mut CEXR_ChannelListIter;
}
extern "C" {
    pub fn CEXR_Header_display_window(header: *const CEXR_Header)
     -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_data_window(header: *const CEXR_Header)
     -> *const CEXR_Box2i;
}
extern "C" {
    pub fn CEXR_Header_set_display_window(header: *mut CEXR_Header,
                                          window: CEXR_Box2i);
}
extern "C" {
    pub fn CEXR_Header_set_data_window(header: *mut CEXR_Header,
                                       window: CEXR_Box2i);
}
extern "C" {
    pub fn CEXR_Header_set_pixel_aspect_ratio(header: *mut CEXR_Header,
                                              aspect_ratio: f32);
}
extern "C" {
    pub fn CEXR_Header_set_screen_window_center(header: *mut CEXR_Header,
                                                center: CEXR_V2f);
}
extern "C" {
    pub fn CEXR_Header_set_screen_window_width(header: *mut CEXR_Header,
                                               width: f32);
}
extern "C" {
    pub fn CEXR_Header_set_line_order(header: *mut CEXR_Header,
                                      line_order: CEXR_LineOrder);
}
extern "C" {
    pub fn CEXR_Header_set_compression(header: *mut CEXR_Header,
                                       compression: CEXR_Compression);
}
extern "C" {
    pub fn CEXR_Header_has_envmap(header: *const CEXR_Header) -> bool;
}
extern "C" {
    pub fn CEXR_Header_envmap(header: *const CEXR_Header)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_Header_set_envmap(header: *mut CEXR_Header,
                                  envmap: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CEXR_Header_erase_attribute(header: *mut CEXR_Header,
                                       attribute:
                                           *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn CEXR_FrameBuffer_new() -> *mut CEXR_FrameBuffer;
}
extern "C" {
    pub fn CEXR_FrameBuffer_delete(framebuffer: *mut CEXR_FrameBuffer);
}
extern "C" {
    pub fn CEXR_FrameBuffer_insert(framebuffer: *mut CEXR_FrameBuffer,
                                   name: *const ::std::os::raw::c_char,
                                   type_: CEXR_PixelType,
                                   base: *mut ::std::os::raw::c_char,
                                   xStride: usize, yStride: usize,
                                   xSampling: ::std::os::raw::c_int,
                                   ySampling: ::std::os::raw::c_int,
                                   fillValue: f64,
                                   xTileCoords: ::std::os::raw::c_int,
                                   yTileCoords: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CEXR_FrameBuffer_get_channel(frame_buffer: *const CEXR_FrameBuffer,
                                        name: *const ::std::os::raw::c_char,
                                        out: *mut CEXR_Channel)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_FrameBuffer_copy_and_offset_scanlines(frame_buffer:
                                                          *const CEXR_FrameBuffer,
                                                      offset:
                                                          ::std::os::raw::c_uint)
     -> *mut CEXR_FrameBuffer;
}
extern "C" {
    pub fn CEXR_InputFile_from_file_path(path: *const ::std::os::raw::c_char,
                                         threads: ::std::os::raw::c_int,
                                         out: *mut *mut CEXR_InputFile,
                                         err_out:
                                             *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_from_stream(stream: *mut CEXR_IStream,
                                      threads: ::std::os::raw::c_int,
                                      out: *mut *mut CEXR_InputFile,
                                      err_out:
                                          *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_delete(file: *mut CEXR_InputFile);
}
extern "C" {
    pub fn CEXR_InputFile_header(file: *mut CEXR_InputFile)
     -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_InputFile_set_framebuffer(file: *mut CEXR_InputFile,
                                          framebuffer: *mut CEXR_FrameBuffer,
                                          err_out:
                                              *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_InputFile_read_pixels(file: *mut CEXR_InputFile,
                                      scanline_1: ::std::os::raw::c_int,
                                      scanline_2: ::std::os::raw::c_int,
                                      err_out:
                                          *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_from_stream(stream: *mut CEXR_OStream,
                                       header: *const CEXR_Header,
                                       threads: ::std::os::raw::c_int,
                                       out: *mut *mut CEXR_OutputFile,
                                       err_out:
                                           *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_delete(file: *mut CEXR_OutputFile);
}
extern "C" {
    pub fn CEXR_OutputFile_header(file: *mut CEXR_OutputFile)
     -> *const CEXR_Header;
}
extern "C" {
    pub fn CEXR_OutputFile_set_framebuffer(file: *mut CEXR_OutputFile,
                                           framebuffer:
                                               *const CEXR_FrameBuffer,
                                           err_out:
                                               *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CEXR_OutputFile_write_pixels(file: *mut CEXR_OutputFile,
                                        num_scanlines: ::std::os::raw::c_int,
                                        err_out:
                                            *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
